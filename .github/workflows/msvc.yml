# Nome do workflow
name: Análise de Código C++ com MSVC

# Gatilhos (triggers) para iniciar o workflow
on:
  # Executa em pull requests para a branch 'main' para validar o código antes do merge
  pull_request:
    branches: [ "main" ]
  # Executa em pushes para a branch 'main' (após o merge)
  push:
    branches: [ "main" ]
  # Permite a execução manual pela interface do GitHub
  workflow_dispatch:
  # Agendamento para execução semanal (toda quarta-feira às 18:38 UTC)
  schedule:
    - cron: '38 18 * * 3'

env:
  # Caminho para o diretório de build do CMake
  BUILD_DIR: '${{ github.workspace }}/build'
  # Diretório de instalação do Vcpkg
  VCPKG_ROOT: '${{ github.workspace }}/vcpkg'

permissions:
  contents: read

jobs:
  analyze:
    # Permissões necessárias para o job
    permissions:
      contents: read              # Para actions/checkout buscar o código
      security-events: write     # Para github/codeql-action/upload-sarif enviar os resultados SARIF
      actions: read              # Necessário em repositórios privados para obter o status da Action

    name: Analisar Código C++
    # Executa em uma máquina virtual Windows mais recente
    runs-on: windows-latest

    # Matriz de estratégia para executar o job com diferentes configurações
    strategy:
      fail-fast: false # Garante que todos os jobs da matriz terminem, mesmo que um falhe
      matrix:
        build_type: [Debug, Release] # Tipos de build a serem testados
        # Você pode adicionar outras variáveis à matriz, como a versão do Visual Studio
        # msvc_version: ['2022', '2019']

    steps:
      # 1. Checkout do código do repositório
      - name: Checkout do repositório
        uses: actions/checkout@v4

      # 2. Configura o cache do Vcpkg para acelerar as execuções futuras
      - name: Cache do Vcpkg
        uses: actions/cache@v4
        with:
          path: ${{ env.VCPKG_ROOT }}
          # A chave de cache é baseada no hash do arquivo vcpkg.json
          key: ${{ runner.os }}-vcpkg-${{ hashFiles('**/vcpkg.json') }}
          restore-keys: |
            ${{ runner.os }}-vcpkg-

      # 3. Adiciona o MSBuild ao PATH para que o CMake o encontre
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      # 4. Configura o projeto com CMake, passando o tipo de build da matriz
      - name: Configurar CMake
        run: >
          cmake -B ${{ env.BUILD_DIR }}
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }}
          -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake

      # 5. Compila o projeto (Build) - Essencial para uma análise de código completa
      - name: Compilar o projeto
        run: cmake --build ${{ env.BUILD_DIR }} --config ${{ matrix.build_type }}

      # 6. Executa a análise de código estático do MSVC
      - name: Inicializar Análise de Código MSVC
        uses: microsoft/msvc-code-analysis-action@04825f6d9e99
        id: run-analysis
        with:
          cmakeBuildDirectory: ${{ env.BUILD_DIR }}
          # Ruleset que define quais checagens serão executadas.
          # 'AllRules.ruleset' é mais completo, mas pode gerar mais avisos.
          # 'NativeRecommendedRules.ruleset' é um bom ponto de partida.
          ruleset: NativeRecommendedRules.ruleset


      # 7. Faz o upload do resultado (arquivo SARIF) para o GitHub Code Scanning
      - name: Upload do SARIF para o GitHub
        uses: github/codeql-action/upload-sarif@v3
        if: success() || failure()
        with:
          sarif_file: ${{ steps.run-analysis.outputs.sarif }}

