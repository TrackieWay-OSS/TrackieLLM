/*
 * Copyright (C) 2025 Pedro Henrique / phdev13
 *
 * File: src/sensors/ffi_bridge.rs
 *
 * This file implements the C-compatible FFI layer for the sensor fusion engine.
 * It exposes a set of `extern "C"` functions that directly correspond to the
 * public API defined in `tk_sensors_fusion.h`.
 *
 * This bridge is the glue that allows the C/C++ parts of the application to
 * use the safe, high-performance sensor fusion logic written in Rust. It
 * handles object lifecycle (creation/destruction), data marshalling (converting
 * C structs to Rust types), and calling the appropriate methods on the
 * `SensorFusionEngine`.
 *
 * SPDX-License-Identifier: AGPL-3.0 license
 */

use crate::sensor_fusion::{MotionState, SensorFusionEngine};
use nalgebra as na;
use std::ffi::c_void;
use std::ptr::null_mut;
use std::slice;

// Re-export C-compatible structs from the tk_sensors_fusion.h header for FFI.
// In a larger build system, these would be generated by bindgen. For now, we
// define them manually to match the header.
#[repr(C)]
pub struct tk_sensor_fusion_config_t {
    pub update_rate_hz: f32,
    pub gyro_trust_factor: f32,
}

#[repr(C)]
pub struct tk_imu_data_t {
    pub timestamp_ns: u64,
    pub acc_x: f32, pub acc_y: f32, pub acc_z: f32,
    pub gyro_x: f32, pub gyro_y: f32, pub gyro_z: f32,
    pub has_mag_data: bool,
    pub mag_x: f32, pub mag_y: f32, pub mag_z: f32,
}

#[repr(C)]
pub struct tk_quaternion_t {
    pub w: f32, pub x: f32, pub y: f32, pub z: f32,
}

#[repr(C)]
pub struct tk_world_state_t {
    pub last_update_timestamp_ns: u64,
    pub orientation: tk_quaternion_t,
    pub motion_state: MotionState,
    pub is_speech_detected: bool,
}

#[repr(C)]
pub enum tk_error_code_t {
    TK_SUCCESS = 0,
    TK_ERROR_INVALID_ARGUMENT = 1001,
    TK_ERROR_OUT_OF_MEMORY = 2000,
}


/// Creates a new Sensor Fusion engine instance and returns a handle to it.
#[no_mangle]
pub extern "C" fn tk_sensor_fusion_create(
    out_engine: *mut *mut SensorFusionEngine,
    config: *const tk_sensor_fusion_config_t,
) -> tk_error_code_t {
    if out_engine.is_null() || config.is_null() {
        return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT;
    }
    let config = unsafe { &*config };
    let engine = Box::new(SensorFusionEngine::new(config.update_rate_hz));
    unsafe {
        *out_engine = Box::into_raw(engine);
    }
    tk_error_code_t::TK_SUCCESS
}

/// Destroys a Sensor Fusion engine instance.
#[no_mangle]
pub extern "C" fn tk_sensor_fusion_destroy(engine_ptr: *mut *mut SensorFusionEngine) {
    if !engine_ptr.is_null() && !unsafe{ (*engine_ptr).is_null() } {
        unsafe {
            let _ = Box::from_raw(*engine_ptr);
            *engine_ptr = null_mut();
        }
    }
}

/// Injects a new IMU data sample into the engine.
#[no_mangle]
pub extern "C" fn tk_sensor_fusion_inject_imu_data(
    engine: *mut SensorFusionEngine,
    imu_data: *const tk_imu_data_t,
) -> tk_error_code_t {
    let engine = unsafe {
        if engine.is_null() { return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT; }
        &mut *engine
    };
    let imu_data = unsafe {
        if imu_data.is_null() { return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT; }
        &*imu_data
    };

    let acc = na::Vector3::new(imu_data.acc_x, imu_data.acc_y, imu_data.acc_z);
    let gyro = na::Vector3::new(imu_data.gyro_x, imu_data.gyro_y, imu_data.gyro_z);
    let mag = if imu_data.has_mag_data {
        Some(na::Vector3::new(imu_data.mag_x, imu_data.mag_y, imu_data.mag_z))
    } else {
        None
    };

    // The delta time is not directly used by the fusion-ahrs update function,
    // as the sample rate is configured at initialization. We can ignore it for now.
    engine.inject_imu_data(&acc, &gyro, &mag, 0.0);
    tk_error_code_t::TK_SUCCESS
}

/// Injects the current Voice Activity Detection state.
#[no_mangle]
pub extern "C" fn tk_sensor_fusion_inject_vad_state(
    engine: *mut SensorFusionEngine,
    is_speech_active: bool,
) -> tk_error_code_t {
     let engine = unsafe {
        if engine.is_null() { return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT; }
        &mut *engine
    };
    engine.inject_vad_state(is_speech_active);
    tk_error_code_t::TK_SUCCESS
}

/// Processes all injected data. In our Rust-centric design, the processing
/// happens during injection, so this function doesn't need to do much.
#[no_mangle]
pub extern "C" fn tk_sensor_fusion_update(
    engine: *mut SensorFusionEngine,
    _delta_time_s: f32,
) -> tk_error_code_t {
    if engine.is_null() {
        return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT;
    }
    // No-op in this design, as processing is continuous on data injection.
    tk_error_code_t::TK_SUCCESS
}

/// Retrieves the latest world state.
#[no_mangle]
pub extern "C" fn tk_sensor_fusion_get_world_state(
    engine: *mut SensorFusionEngine,
    out_state: *mut tk_world_state_t,
) -> tk_error_code_t {
    let engine = unsafe {
        if engine.is_null() { return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT; }
        &*engine
    };
     let out_state = unsafe {
        if out_state.is_null() { return tk_error_code_t::TK_ERROR_INVALID_ARGUMENT; }
        &mut *out_state
    };

    let rust_state = engine.get_world_state();

    out_state.last_update_timestamp_ns = rust_state.last_update_timestamp_ns;
    out_state.orientation.w = rust_state.orientation.w;
    out_state.orientation.x = rust_state.orientation.x;
    out_state.orientation.y = rust_state.orientation.y;
    out_state.orientation.z = rust_state.orientation.z;
    out_state.motion_state = rust_state.motion_state;
    out_state.is_speech_detected = rust_state.is_speech_detected;

    tk_error_code_t::TK_SUCCESS
}
