/*
 * Copyright (C) 2025 Pedro Henrique / phdev13
 *
 * File: src/navigation/free_space.rs
 *
 * This file provides the primary Rust implementation for the Free Space Detector.
 * It is called by the C FFI wrappers in `tk_free_space_detector.c`.
 *
 * The logic here is a direct translation and enhancement of the original C
 * implementation, providing a safe and robust way to analyze a traversability
 * map and characterize the surrounding free space into angular sectors.
 *
 * SPDX-License-Identifier: AGPL-3.0 license
 */

// These C-compatible structs are redefined here for clarity. In a larger project,
// they would be generated by a tool like `bindgen`.
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TraversabilityType {
    Unknown,
    Traversable,
    Obstacle,
    HazardStepUp,
    HazardStepDown,
    HazardHole,
}

#[repr(C)]
pub struct TraversabilityMap<'a> {
    pub width: u32,
    pub height: u32,
    pub resolution_m_per_cell: f32,
    pub grid: &'a [TraversabilityType],
}

#[repr(C)]
#[derive(Debug, Default, Clone, Copy)]
pub struct SpaceSector {
    pub center_angle_deg: f32,
    pub max_clear_distance_m: f32,
    pub is_clear: bool,
}

// The main Rust struct for the free space detector.
// The `tk_free_space_detector_t` in C is an opaque pointer to this.
pub struct FreeSpaceDetector {
    config: FreeSpaceConfig,
    sectors: Vec<SpaceSector>,
}

#[derive(Debug, Clone, Copy)]
pub struct FreeSpaceConfig {
    pub num_angular_sectors: u32,
    pub analysis_fov_deg: f32,
}

impl FreeSpaceDetector {
    pub fn new(config: FreeSpaceConfig) -> Self {
        let mut sectors = Vec::with_capacity(config.num_angular_sectors as usize);
        let sector_width = config.analysis_fov_deg / config.num_angular_sectors as f32;
        let start_angle = -config.analysis_fov_deg / 2.0;

        for i in 0..config.num_angular_sectors {
            sectors.push(SpaceSector {
                center_angle_deg: start_angle + (i as f32 + 0.5) * sector_width,
                ..Default::default()
            });
        }
        Self { config, sectors }
    }

    pub fn analyze(&mut self, map: &TraversabilityMap) {
        // Reset sectors
        for sector in self.sectors.iter_mut() {
            sector.max_clear_distance_m = 0.0;
            sector.is_clear = false;
        }

        let grid_center_x = map.width as f32 / 2.0;

        for y in 0..map.height {
            for x in 0..map.width {
                let idx = (y * map.width + x) as usize;
                if map.grid[idx] != TraversabilityType::Traversable {
                    continue;
                }

                let world_x = (x as f32 - grid_center_x) * map.resolution_m_per_cell;
                let world_y = y as f32 * map.resolution_m_per_cell;

                let distance = (world_x * world_x + world_y * world_y).sqrt();
                let angle_rad = world_x.atan2(world_y);
                let angle_deg = angle_rad.to_degrees();

                if angle_deg.abs() > self.config.analysis_fov_deg / 2.0 {
                    continue;
                }

                let sector_width = self.config.analysis_fov_deg / self.config.num_angular_sectors as f32;
                let start_angle = -self.config.analysis_fov_deg / 2.0;
                let sector_idx = ((angle_deg - start_angle) / sector_width) as usize;

                if let Some(sector) = self.sectors.get_mut(sector_idx) {
                    if distance > sector.max_clear_distance_m {
                        sector.max_clear_distance_m = distance;
                    }
                }
            }
        }

        // Post-process to determine if a sector is "clear"
        for sector in self.sectors.iter_mut() {
             // A simple heuristic for now
            if sector.max_clear_distance_m > 1.0 {
                sector.is_clear = true;
            }
        }
    }

    pub fn get_sectors(&self) -> &[SpaceSector] {
        &self.sectors
    }
}
