/*
 * Copyright (C) 2025 Pedro Henrique / phdev13
 *
 * File: src/utils/error_utils.rs
 *
 * This file implements the primary error handling infrastructure for the Rust
 * side of the application. It defines a comprehensive `TrackieError` enum that
 * serves as a unified error type for all crates.
 *
 * It uses bindings generated by `bindgen` from the C `tk_error_handling.h`
 * header to ensure the error codes are always in sync. This avoids manual
 * duplication and makes error propagation across the FFI boundary safe and
 * reliable.
 *
 * The `From` trait is implemented to automatically convert a C error code
 * into a rich, structured Rust error, capturing both the generic error string
 * and the specific, thread-local detail message.
 *
 * Dependencies:
 *   - thiserror: For ergonomic error enum definitions.
 *
 * SPDX-License-Identifier: AGPL-3.0 license
 */

use std::ffi::CStr;
use thiserror::Error;

// This block includes the Rust bindings generated by `bindgen` from the C header.
// The `bindings.rs` file is created in the `OUT_DIR` during the build process.
pub mod ffi {
    #![allow(non_upper_case_globals)]
    #![allow(non_camel_case_types)]
    #![allow(non_snake_case)]
    #![allow(dead_code)]
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

    // We also need to declare the C functions we'll be calling.
    // In a larger project, these might also be in the generated bindings.
    extern "C" {
        pub fn tk_error_to_string(code: tk_error_code_t) -> *const ::std::os::raw::c_char;
        pub fn tk_error_get_detail() -> *const ::std::os::raw::c_char;
    }
}

// Re-export the generated enum for easier use throughout the crate.
pub use ffi::tk_error_code_t;


/// The primary, unified error type for the entire TrackieLLM Rust application.
///
/// This enum consolidates errors from all possible sources, including FFI calls,
/// I/O operations, and module-specific failures.
#[derive(Debug, Error)]
pub enum TrackieError {
    /// An error that originated from the C side of the codebase.
    #[error("Core C/C++ Error: {message} (Code: {code:?}) - Detail: {detail}")]
    CoreError {
        /// The specific C error code.
        code: tk_error_code_t,
        /// The generic, descriptive message for the error code.
        message: String,
        /// The specific, contextual detail message from the thread-local storage.
        detail: String,
    },

    /// An error from one of the utility modules.
    #[error("Utility Error: {0}")]
    Utils(#[from] crate::UtilsError),
    // In a real application, you would add variants for every other crate.
}

impl From<tk_error_code_t> for TrackieError {
    /// Converts a raw C error code into a structured `TrackieError`.
    ///
    /// This function calls the `tk_error_to_string` FFI function to get the
    /// generic descriptive message and `tk_error_get_detail` for the specific
    /// contextual message.
    fn from(code: tk_error_code_t) -> Self {
        if code == tk_error_code_t::TK_SUCCESS {
            // This should ideally not happen, but as a safeguard:
            return TrackieError::CoreError {
                code,
                message: "Success code treated as error".to_string(),
                detail: "A function returned TK_SUCCESS, which was then incorrectly converted to an error.".to_string(),
            };
        }

        // Unsafe block is required to call FFI functions.
        let (message, detail) = unsafe {
            // Get the generic error string.
            let c_str_ptr = ffi::tk_error_to_string(code);
            let message = if c_str_ptr.is_null() {
                "Failed to get error string from C".to_string()
            } else {
                CStr::from_ptr(c_str_ptr).to_string_lossy().into_owned()
            };

            // Get the detailed error string.
            let detail_ptr = ffi::tk_error_get_detail();
            let detail = if detail_ptr.is_null() {
                "".to_string() // Should return empty string, not null, but good to be safe.
            } else {
                CStr::from_ptr(detail_ptr).to_string_lossy().into_owned()
            };

            (message, detail)
        };

        TrackieError::CoreError { code, message, detail }
    }
}
