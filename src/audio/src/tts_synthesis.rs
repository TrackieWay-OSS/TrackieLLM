/*
 * Copyright (C) 2025 Pedro Henrique / phdev13
 *
 * File: src/audio/tts_synthesis.rs
 *
 * This file provides a safe Rust wrapper for the Piper TTS (Text-to-Speech)
 * engine, as defined in `tk_tts_piper.h`.
 *
 * The `TtsService` struct encapsulates the `unsafe` FFI calls to the C-level
 * Piper implementation. It manages the lifecycle of the `tk_tts_piper_context_t`
 * handle using the RAII pattern, ensuring that the C-level resources are
 * properly released when the service is no longer in use.
 *
 * SPDX-License-Identifier: AGPL-3.0 license
 */

use std::ffi::{c_void, CString};
use std::os::raw::{c_char, c_int};
use std::ptr::{null_mut, NonNull};
use thiserror::Error;

// --- FFI bindings for tk_tts_piper.h ---
// This is a simplified, manual binding. In a larger project, this would be
// generated by `bindgen`.
mod ffi {
    use super::*;

    // Opaque handle
    #[repr(C)]
    pub struct tk_tts_piper_context_s {
        _private: [u8; 0],
    }
    pub type TkTtsPiperContextT = tk_tts_piper_context_s;

    // Placeholder for tk_path_t from internal_tools
    #[repr(C)]
    pub struct tk_path_t { _private: [u8; 0] }

    #[repr(C)]
    #[derive(Debug, Clone, Copy)]
    pub struct tk_tts_piper_voice_params_t {
        pub speaker_id: c_int,
        pub length_scale: f32,
        pub noise_scale: f32,
        pub noise_w: f32,
    }

    #[repr(C)]
    pub struct tk_tts_piper_config_t {
        pub model_path: *mut tk_path_t,
        pub config_path: *mut tk_path_t,
        pub language: *const c_char,
        pub sample_rate: u32,
        pub user_data: *mut c_void,
        pub voice_params: tk_tts_piper_voice_params_t,
        pub n_threads: c_int,
        pub audio_buffer_size: usize,
    }

    // We need the tk_path functions to create paths for the config
    #[link(name = "trackie")]
    extern "C" {
        pub fn tk_path_create(path_str: *const c_char) -> *mut tk_path_t;
        pub fn tk_path_destroy(path: *mut tk_path_t);
    }

    // Bindings for the TTS functions
    #[link(name = "trackie")]
    extern "C" {
        pub fn tk_tts_piper_create(
            out_context: *mut *mut TkTtsPiperContextT,
            config: *const tk_tts_piper_config_t,
        ) -> c_int;

        pub fn tk_tts_piper_destroy(context: *mut *mut TkTtsPiperContextT);

        pub fn tk_tts_piper_synthesize_to_buffer(
            context: *mut TkTtsPiperContextT,
            text: *const c_char,
            out_audio_data: *mut *mut i16,
            out_frame_count: *mut usize,
        ) -> c_int;
    }
}

/// Represents errors specific to the TTS synthesis process.
#[derive(Debug, Error)]
pub enum TtsError {
    /// Failed to create the TTS context.
    #[error("Failed to create TTS context. Error code: {0}")]
    ContextCreation(c_int),

    /// Failed to synthesize audio.
    #[error("Failed to synthesize audio. Error code: {0}")]
    Synthesis(c_int),

    /// The text provided for synthesis was invalid (e.g., contained null bytes).
    #[error("Invalid input text for synthesis: {0}")]
    InvalidInputText(#[from] std::ffi::NulError),

    /// The path provided for model or config was invalid.
    #[error("Invalid path string: {0}")]
    InvalidPath(#[from] std::str::Utf8Error),
}

/// Configuration for the TtsService.
pub struct TtsConfig<'a> {
    pub model_path: &'a str,
    pub config_path: &'a str,
    pub n_threads: c_int,
}

/// A safe, high-level interface to the Piper TTS Engine.
pub struct TtsService {
    context: NonNull<ffi::TkTtsPiperContextT>,
}

impl TtsService {
    /// Creates a new `TtsService`.
    pub fn new(config: TtsConfig) -> Result<Self, TtsError> {
        // Create C-compatible strings for paths
        let model_path_cstr = CString::new(config.model_path)?;
        let config_path_cstr = CString::new(config.config_path)?;

        // Create tk_path_t objects using the C API
        let model_path_ptr = unsafe { ffi::tk_path_create(model_path_cstr.as_ptr()) };
        let config_path_ptr = unsafe { ffi::tk_path_create(config_path_cstr.as_ptr()) };

        if model_path_ptr.is_null() || config_path_ptr.is_null() {
            // Should not happen if CString creation succeeds
            return Err(TtsError::ContextCreation(-1));
        }

        let c_config = ffi::tk_tts_piper_config_t {
            model_path: model_path_ptr,
            config_path: config_path_ptr,
            language: null_mut(),
            sample_rate: 0,
            user_data: null_mut(),
            voice_params: ffi::tk_tts_piper_voice_params_t {
                speaker_id: 0,
                length_scale: 1.0,
                noise_scale: 0.667,
                noise_w: 0.8,
            },
            n_threads: config.n_threads,
            audio_buffer_size: 0,
        };

        let mut context_handle: *mut ffi::TkTtsPiperContextT = null_mut();
        let result = unsafe {
            ffi::tk_tts_piper_create(&mut context_handle, &c_config)
        };

        // Clean up the path objects
        unsafe {
            ffi::tk_path_destroy(model_path_ptr);
            ffi::tk_path_destroy(config_path_ptr);
        }

        if result == 0 && !context_handle.is_null() {
            Ok(Self {
                context: NonNull::new(context_handle).unwrap(),
            })
        } else {
            Err(TtsError::ContextCreation(result))
        }
    }

    /// Synthesizes text into a buffer of audio data.
    ///
    /// The returned `Vec<i16>` contains the raw PCM audio data.
    pub fn synthesize_to_buffer(&self, text: &str) -> Result<Vec<i16>, TtsError> {
        // 1. Validate and sanitize the text.
        let sanitized_text = text.replace(|c: char| c.is_control() && c != '\n' && c != '\t', " ");
        let c_text = CString::new(sanitized_text)?;

        // 2. Prepare pointers for the output.
        let mut audio_data_ptr: *mut i16 = null_mut();
        let mut frame_count: usize = 0;

        // 3. Make the unsafe FFI call.
        let result = unsafe {
            ffi::tk_tts_piper_synthesize_to_buffer(
                self.context.as_ptr(),
                c_text.as_ptr(),
                &mut audio_data_ptr,
                &mut frame_count,
            )
        };

        // 4. Handle the result.
        if result == 0 && !audio_data_ptr.is_null() && frame_count > 0 {
            // Success: copy the data into a safe Vec and free the C buffer.
            let audio_vec = unsafe {
                Vec::from_raw_parts(audio_data_ptr, frame_count, frame_count)
            };
            Ok(audio_vec)
        } else {
            // Failure: ensure the buffer is freed if it was allocated.
            if !audio_data_ptr.is_null() {
                unsafe { libc::free(audio_data_ptr as *mut c_void) };
            }
            Err(TtsError::Synthesis(result))
        }
    }
}

// Implement Drop to ensure the C context is always freed (RAII).
impl Drop for TtsService {
    fn drop(&mut self) {
        let mut context_handle = self.context.as_ptr();
        unsafe {
            ffi::tk_tts_piper_destroy(&mut context_handle);
        }
    }
}

// --- Unit Tests ---

#[cfg(test)]
mod tests {
    use super::*;

    // NOTE: These tests require the Piper model files to be present at this path.
    // Since we can't guarantee that in the CI environment, the tests that
    // require the model are marked with `#[ignore]`.
    const MODEL_PATH: &str = "assets/models/piper/en_US-lessac-medium.onnx";
    const CONFIG_PATH: &str = "assets/models/piper/en_US-lessac-medium.onnx.json";

    #[test]
    fn test_text_validation_with_null_byte() {
        // This test does not require the model to be loaded.
        // It checks if the CString validation catches null bytes.
        let text_with_null = "Hello\0World";
        let _config = TtsConfig {
            model_path: MODEL_PATH,
            config_path: CONFIG_PATH,
            n_threads: 1,
        };
        // We don't need to create the service, just test the validation step.
        let result = CString::new(text_with_null);
        assert!(matches!(result, Err(_)));
    }

    #[test]
    fn test_text_sanitization() {
        // This test checks if control characters are properly handled.
        let text = "Hello\x01World";
        let sanitized_text = text.replace(|c: char| c.is_control() && c != '\n' && c != '\t', " ");
        let result = CString::new(sanitized_text);
        assert!(result.is_ok());
        assert_eq!(result.unwrap().to_str().unwrap(), "Hello World");
    }

    #[test]
    #[ignore] // This test requires model files to be present.
    fn test_service_creation_and_destruction() {
        let config = TtsConfig {
            model_path: MODEL_PATH,
            config_path: CONFIG_PATH,
            n_threads: 2,
        };

        // The test passes if `new` succeeds and `drop` is called without panicking.
        let service = TtsService::new(config);
        assert!(service.is_ok());
    }

    #[test]
    #[ignore] // This test requires model files to be present.
    fn test_synthesis() {
        let config = TtsConfig {
            model_path: MODEL_PATH,
            config_path: CONFIG_PATH,
            n_threads: 2,
        };

        let service = TtsService::new(config).expect("Failed to create TTS service for test.");

        let result = service.synthesize_to_buffer("Hello, world.");

        assert!(result.is_ok());
        let audio_buffer = result.unwrap();
        assert!(!audio_buffer.is_empty());
        println!("Synthesized audio buffer with {} frames.", audio_buffer.len());
    }
}
