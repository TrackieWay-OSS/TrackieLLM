/*
* Copyright (C) 2025 Pedro Henrique / phdev13
*
* File: tk_audio_pipeline.h
*
* This header file defines the public API for the TrackieLLM Audio Pipeline.
* This subsystem is responsible for all audio-related processing, acting as the
* "ears" and "voice" of the system. It is architected as a stateful, real-time,
* stream-processing engine.
*
* The core design is event-driven and asynchronous. The host application (Cortex)
* continuously feeds raw audio chunks into the pipeline. The pipeline processes
* this stream internally and notifies the host of significant events via a
* callback mechanism. This is crucial for a responsive voice assistant.
*
* The pipeline encapsulates and orchestrates several AI models and components:
*   1. Voice Activity Detection (VAD): To detect the presence of human speech
*      and ignore silence or background noise, saving computational resources.
*   2. Automatic Speech Recognition (ASR): To transcribe spoken words into text
*      using a model like Whisper.cpp.
*   3. Text-to-Speech (TTS): To synthesize text responses into audible speech
*      using a model like Piper.
*
* All resources are managed internally by the opaque `tk_audio_pipeline_t`
* object, ensuring a clean and safe API for the consumer.
*
* SPDX-License-Identifier: AGPL-3.0 license
*/

#ifndef TRACKIELLM_AUDIO_TK_AUDIO_PIPELINE_H
#define TRACKIELLM_AUDIO_TK_AUDIO_PIPELINE_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "utils/tk_error_handling.h"
#include "internal_tools/tk_file_manager.h"
#include "tk_decision_engine.h" // Include for priority enum

// Forward-declare the primary pipeline object as an opaque type.
typedef struct tk_audio_pipeline_s tk_audio_pipeline_t;

/**
 * @struct tk_audio_params_t
 * @brief Defines the properties of the audio stream being processed.
 *
 * These parameters must match the audio source (microphone) and are used to
 * configure all internal audio components (VAD, ASR, etc.).
 */
typedef struct {
    uint32_t sample_rate;       /**< Sample rate in Hz (e.g., 16000 for Whisper). */
    uint32_t channels;          /**< Number of audio channels (must be 1 for mono). */
} tk_audio_params_t;

/**
 * @enum tk_pipeline_state_e
 * @brief Defines the operational state of the audio pipeline.
 */
typedef enum {
    TK_PIPELINE_STATE_IDLE,                 /**< Pipeline is created but not actively processing. */
    TK_PIPELINE_STATE_AWAITING_WAKE_WORD,   /**< Actively listening only for the wake word (low power). */
    TK_PIPELINE_STATE_LISTENING_FOR_COMMAND,/**< Wake word detected, now listening for a voice command. */
    TK_PIPELINE_STATE_TRANSCRIBING,         /**< Command audio is being transcribed by ASR. */
    TK_PIPELINE_STATE_SYNTHESIZING,         /**< A text response is being synthesized into speech by TTS. */
} tk_pipeline_state_e;


/**
 * @struct tk_audio_pipeline_config_t
 * @brief Comprehensive configuration for initializing the audio pipeline.
 */
typedef struct {
    tk_audio_params_t input_audio_params; /**< Parameters of the incoming audio stream. */
    const char*       user_language;      /**< Language code (e.g., "en", "pt") for ASR and TTS. */
    void*             user_data;          /**< Opaque pointer passed to all callbacks. */

    // Model Paths
    tk_path_t*        asr_model_path;     /**< Path to the Whisper.cpp GGML model file. */
    tk_path_t*        vad_model_path;     /**< Path to the Silero VAD ONNX model file. */
    tk_path_t*        tts_model_path;     /**< Path to the Piper TTS ONNX model file. */
    tk_path_t*        tts_config_path;    /**< Path to the Piper TTS JSON config file. */
    tk_path_t*        ww_model_path;      /**< Path to the Porcupine model file (.pv). */
    tk_path_t*        ww_keyword_path;    /**< Path to the Porcupine keyword file (.ppn). */
    float             ww_sensitivity;     /**< Sensitivity for the wake word (0.0 to 1.0). */


    // VAD specific parameters
    float             vad_silence_threshold_ms; /**< How long silence must be before speech is considered ended. */
    float             vad_speech_probability_threshold; /**< Confidence threshold for VAD (0.0 to 1.0). */
} tk_audio_pipeline_config_t;

/**
 * @enum tk_vad_event_e
 * @brief Enumerates the events generated by the Voice Activity Detector.
 */
typedef enum {
    TK_VAD_EVENT_SPEECH_STARTED, /**< The VAD has detected the beginning of a speech segment. */
    TK_VAD_EVENT_SPEECH_ENDED    /**< The VAD has detected the end of a speech segment (after a period of silence). */
} tk_vad_event_e;

/**
 * @struct tk_transcription_t
 * @brief Holds the result of a speech recognition operation.
 */
typedef struct {
    const char* text;           /**< The transcribed text (UTF-8). Valid only for the duration of the callback. */
    bool        is_final;       /**< True if this is the final, confirmed transcription for a speech segment.
                                     False if it's an intermediate, partial result. */
    float       confidence;     /**< An overall confidence score for the transcription (if available). */
} tk_transcription_t;

//------------------------------------------------------------------------------
// Callback Function Pointers
//------------------------------------------------------------------------------

/**
 * @brief Callback for VAD state changes.
 * @param event The type of VAD event that occurred.
 * @param user_data The opaque user data pointer from the configuration.
 */
typedef void (*tk_on_vad_event_cb)(tk_vad_event_e event, void* user_data);

/**
 * @brief Callback for ASR transcription results.
 * @param result A pointer to the transcription result structure. This pointer
 *               and its contents are only valid for the duration of the callback.
 * @param user_data The opaque user data pointer from the configuration.
 */
typedef void (*tk_on_transcription_cb)(const tk_transcription_t* result, void* user_data);

/**
 * @brief Callback for delivering synthesized speech audio from TTS.
 * This is the same type as defined in tk_cortex_main.h, for consistency.
 * @param audio_data Pointer to the raw PCM audio data (16-bit signed mono).
 * @param frame_count The number of audio frames in the buffer.
 * @param sample_rate The sample rate of the audio.
 * @param user_data The opaque user data pointer from the configuration.
 */
typedef void (*tk_on_tts_audio_ready_cb)(const int16_t* audio_data, size_t frame_count, uint32_t sample_rate, void* user_data);

/**
 * @struct tk_audio_callbacks_t
 * @brief A structure to hold all callback functions for the audio pipeline.
 */
typedef struct {
    tk_on_vad_event_cb       on_vad_event;
    tk_on_transcription_cb   on_transcription;
    tk_on_tts_audio_ready_cb on_tts_audio_ready;
} tk_audio_callbacks_t;

#ifdef __cplusplus
extern "C" {
#endif

//------------------------------------------------------------------------------
// Pipeline Lifecycle Management
//------------------------------------------------------------------------------

/**
 * @brief Creates and initializes a new audio pipeline instance.
 *
 * This function loads all required audio models (VAD, ASR, TTS), initializes
 * their respective inference engines, and sets up internal buffers and state
 * machines. This can be a time-consuming operation.
 *
 * @param[out] out_pipeline A pointer to a tk_audio_pipeline_t* that will receive
 *                          the address of the newly created pipeline instance.
 * @param[in] config A pointer to the configuration structure.
 * @param[in] callbacks A structure containing the callback function pointers.
 *
 * @return TK_SUCCESS on successful creation.
 * @return TK_ERROR_INVALID_ARGUMENT if any required pointers are NULL or config is invalid.
 * @return TK_ERROR_OUT_OF_MEMORY if memory allocation fails.
 * @return TK_ERROR_MODEL_LOAD_FAILED if any of the audio models cannot be loaded.
 */
TK_NODISCARD tk_error_code_t tk_audio_pipeline_create(tk_audio_pipeline_t** out_pipeline, const tk_audio_pipeline_config_t* config, tk_audio_callbacks_t callbacks);

/**
 * @brief Destroys an audio pipeline instance and frees all associated resources.
 *
 * @param[in,out] pipeline A pointer to the tk_audio_pipeline_t* to be destroyed.
 *                         The pointer is set to NULL after destruction.
 */
void tk_audio_pipeline_destroy(tk_audio_pipeline_t** pipeline);

//------------------------------------------------------------------------------
// Core Data Flow and Control Functions
//------------------------------------------------------------------------------

/**
 * @brief Processes a chunk of raw audio data.
 *
 * This is the primary input function for the pipeline. The Cortex should call
 * this continuously with data from the microphone. The function is designed to
* be non-blocking and fast, placing the data into an internal ring buffer for
 * a background processing thread to consume.
 *
 * @param[in] pipeline The audio pipeline instance.
 * @param[in] audio_chunk Pointer to the raw audio data (16-bit signed mono PCM).
 * @param[in] frame_count The number of audio frames in the chunk.
 *
 * @return TK_SUCCESS on success.
 * @return TK_ERROR_INVALID_ARGUMENT if pipeline or audio_chunk is NULL.
 * @return TK_ERROR_BUFFER_TOO_SMALL if the internal buffer is full (indicates
 *         the processing thread is falling behind).
 *
 * @par Thread-Safety
 * This function is thread-safe and designed to be called from a high-priority
 * audio capture thread.
 */
TK_NODISCARD tk_error_code_t tk_audio_pipeline_process_chunk(tk_audio_pipeline_t* pipeline, const int16_t* audio_chunk, size_t frame_count);

/**
 * @brief Requests the synthesis of a text string into speech with priority.
 *
 * This function is non-blocking. It queues a TTS request to be processed by the
 * pipeline's worker thread. The resulting audio will be delivered in chunks
 * via the `on_tts_audio_ready` callback.
 *
 * @param[in] pipeline The audio pipeline instance.
 * @param[in] text_to_speak The UTF-8 encoded text to be synthesized.
 * @param[in] priority The priority level for this TTS request.
 *
 * @return TK_SUCCESS if the request was successfully queued.
 * @return TK_ERROR_INVALID_ARGUMENT if pipeline or text_to_speak is NULL.
 * @return TK_ERROR_INVALID_STATE if the TTS engine is not initialized or is busy.
 *
 * @par Thread-Safety
 * This function is thread-safe.
 */
TK_NODISCARD tk_error_code_t tk_audio_pipeline_synthesize_text(
    tk_audio_pipeline_t* pipeline, 
    const char* text_to_speak,
    tk_response_priority_e priority // Added priority parameter
);

/**
 * @brief Forces the ASR to finalize its current transcription.
 *
 * Can be used by the Cortex to interrupt a user's speech or to signal that no
 * more speech is expected, triggering an immediate `on_transcription` callback
 * with `is_final = true`.
 *
 * @param[in] pipeline The audio pipeline instance.
 * @return TK_SUCCESS on success.
 *
 * @par Thread-Safety
 * This function is thread-safe.
 */
TK_NODISCARD tk_error_code_t tk_audio_pipeline_force_transcription_end(tk_audio_pipeline_t* pipeline);


//------------------------------------------------------------------------------
// Standalone Utility Functions
//------------------------------------------------------------------------------

/**
 * @brief A simple, blocking function to synthesize and play text directly.
 *
 * This is a utility function for cases where a simple, one-off speech
 * output is needed without the complexity of the full asynchronous pipeline.
 * It initializes a temporary TTS engine, synthesizes the text to a buffer,
 * plays the audio on the default output device, and then cleans up.
 *
 * NOTE: This function can be slow to execute due to model loading and is
 * not suitable for real-time, low-latency responses. Use the main pipeline
 * for that purpose.
 *
 * @param[in] text The UTF-8 encoded text to be spoken.
 * @param[in] model_path Path to the Piper ONNX model file.
 * @param[in] config_path Path to the Piper JSON config file.
 *
 * @return TK_SUCCESS on success.
 * @return TK_ERROR_INVALID_ARGUMENT if text or paths are NULL.
 * @return TK_ERROR_MODEL_LOAD_FAILED if the TTS model cannot be loaded.
 * @return TK_ERROR_EXTERNAL_LIBRARY_FAILED if audio playback fails.
 */
TK_NODISCARD tk_error_code_t tk_audio_pipeline_say(
    const char* text,
    const char* model_path,
    const char* config_path
);


#ifdef __cplusplus
}
#endif

#endif // TRACKIELLM_AUDIO_TK_AUDIO_PIPELINE_H
