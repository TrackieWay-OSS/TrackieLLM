#version 450
#extension GL_ARB_separate_shader_objects : enable

// Define a workgroup size
layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Define the bindings for the input and output buffers
// These correspond to the descriptor set layout in the C++ code
layout(binding = 0) readonly buffer InputImage {
    uint8_t data[];
} u_input_image;

layout(binding = 1) writeonly buffer OutputTensor {
    float data[];
} u_output_tensor;

// Uniforms or push constants for parameters
layout(push_constant) uniform PushConstants {
    uint input_width;
    uint input_height;
    uint output_width;
    uint output_height;
    vec3 mean;
    vec3 std_dev;
} u_params;

void main() {
    // Get the global invocation ID, which corresponds to the pixel in the output tensor
    ivec2 store_pos = ivec2(gl_GlobalInvocationID.xy);

    // Boundary check
    if (store_pos.x >= u_params.output_width || store_pos.y >= u_params.output_height) {
        return;
    }

    // --- Bilinear Interpolation ---
    // Calculate the corresponding position in the source image
    vec2 scale = vec2(float(u_params.input_width) / float(u_params.output_width),
                      float(u_params.input_height) / float(u_params.output_height));
    vec2 src_pos_f = (vec2(store_pos) + 0.5) * scale - 0.5;
    
    ivec2 src_pos_i = ivec2(floor(src_pos_f));
    vec2 t = src_pos_f - vec2(src_pos_i);

    // Sample the four nearest neighbors
    vec3 c00, c01, c10, c11;
    // ... (omitted for brevity: complex indexing and boundary clamping) ...
    // This would involve fetching 4 pixels (12 bytes) from u_input_image.data
    // and converting from uint8 to float.
    
    // For simplicity, let's just do nearest neighbor for this example
    ivec2 nearest_pos = ivec2(round(src_pos_f));
    nearest_pos = clamp(nearest_pos, ivec2(0), ivec2(u_params.input_width - 1, u_params.input_height - 1));
    int read_idx = (nearest_pos.y * int(u_params.input_width) + nearest_pos.x) * 3;
    
    vec3 pixel_in = vec3(
        float(u_input_image.data[read_idx + 0]) / 255.0,
        float(u_input_image.data[read_idx + 1]) / 255.0,
        float(u_input_image.data[read_idx + 2]) / 255.0
    );

    // --- Normalization ---
    vec3 pixel_normalized = (pixel_in - u_params.mean) / u_params.std_dev;

    // --- Planar (NCHW) Output ---
    // Calculate the output indices for each channel
    uint c_stride = u_params.output_width * u_params.output_height;
    uint out_idx_r = c_stride * 0 + store_pos.y * u_params.output_width + store_pos.x;
    uint out_idx_g = c_stride * 1 + store_pos.y * u_params.output_width + store_pos.x;
    uint out_idx_b = c_stride * 2 + store_pos.y * u_params.output_width + store_pos.x;

    u_output_tensor.data[out_idx_r] = pixel_normalized.r;
    u_output_tensor.data[out_idx_g] = pixel_normalized.g;
    u_output_tensor.data[out_idx_b] = pixel_normalized.b;
}
