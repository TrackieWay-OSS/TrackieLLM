/*
 * Copyright (C) 2025 Pedro Henrique / phdev13
 *
 * File: src/security/lib.rs
 *
 * This file is the main library entry point for the 'security' crate. It
 * provides a unified, high-level, and safe Rust API for all security-related
 * operations within the TrackieLLM application. The crate encapsulates FFI
 * calls to the underlying C components for authentication (`tk_auth_manager`)
 * and encryption (`tk_encryption`), ensuring that all interactions with unsafe
 * C code are handled with robust error management and memory safety guarantees.
 *
 * The primary goals of this crate are:
 * 1.  **Safety**: To provide a memory-safe and type-safe interface over the C
 *     FFI, preventing common C programming errors like buffer overflows, null
 *     pointer dereferences, and resource leaks.
 * 2.  **Ergonomics**: To offer an idiomatic Rust API that leverages Rust's
 *     powerful features like the type system, RAII (via the Drop trait),
 *     enums for error handling, and iterators.
 * 3.  **Abstraction**: To hide the complexities of the underlying C implementation,
 *     presenting a clean and cohesive security service to the rest of the
 *     application.
 *
 * The main components are `key_management` for handling cryptographic keys and
 * `secure_channels` for establishing secure communication links.
 *
 * Dependencies:
 *   - ffi-bindings: The crate containing the raw `unsafe` bindings to the C API.
 *   - log: For structured logging of security events.
 *   - thiserror: For creating a comprehensive error enum.
 *   - zeroize: For securely clearing sensitive data from memory.
 *
 * SPDX-License-Identifier: AGPL-3.0 license
 */

// === TOC ===
// 1. Crate-level Documentation & Attributes
// 2. FFI Bindings Module (private)
// 3. Public Module Declarations
// 4. Public Prelude
// 5. Core Public Types (Error, etc.)
// 6. Main Service Interface (SecurityService - TBD)
// =============

#![deny(unsafe_code)]
#![deny(missing_docs)]
#![deny(warnings)]

//! # TrackieLLM Security Crate
//!
//! Provides core security functionalities including cryptography, authentication,
//! and secure session management. This crate acts as a safe Rust faÃ§ade over the
//! project's C-based security primitives.
//!
//! ## Features
//!
//! - **Key Management**: Secure generation, storage, and handling of cryptographic keys.
//! - **Data Encryption**: Authenticated encryption and decryption of data buffers.
//! - **Secure Channels**: (Future) Establishment of secure communication channels.
//! - **Authentication**: (Future) User and device authentication services.
//!
//! ## Design Philosophy
//!
//! The guiding principle is "defense in depth". We do not trust any single
//! component to be infallible. The Rust layer adds compile-time guarantees
//! on top of the C implementation's runtime checks.
//!
//! - **RAII**: All handles to C-level resources (`tk_auth_manager_t`,
//!   `tk_encryption_ctx_t`) are wrapped in structs that implement the `Drop`
//!   trait, ensuring that resources are always released and sensitive data is
//!   cleared, even in the case of panics.
//! - **Error Handling**: All C-level error codes are translated into a rich
//!   `SecurityError` enum, providing clear and actionable error information.
//! - **Type Safety**: Raw pointers and integer-based handles from C are
//!   converted into strongly-typed Rust equivalents to prevent misuse.

// --- FFI Bindings Module ---
// This private module will contain the raw, unsafe FFI declarations.
// By keeping it private, we enforce that all interaction with the C API
// must go through the safe abstractions provided by this crate.
// For this example, we assume the bindings are generated by a tool like
// bindgen and are available in a separate `ffi_bindings` crate or module.
mod ffi {
    // In a real project, this would be more extensive.
    // We are including placeholder definitions based on the .h files.
    // Note: The actual FFI would be in a separate crate, but for demonstration
    // it is included here.
    #![allow(non_camel_case_types, non_snake_case, dead_code)]
    pub type tk_error_code_t = i32;
    pub const TK_SUCCESS: tk_error_code_t = 0;

    // From tk_encryption.h
    pub enum tk_encryption_ctx_s {}
    pub type tk_encryption_ctx_t = tk_encryption_ctx_s;

    extern "C" {
        pub fn tk_encryption_ctx_create(ctx: *mut *mut tk_encryption_ctx_t) -> tk_error_code_t;
        pub fn tk_encryption_ctx_destroy(ctx: *mut *mut tk_encryption_ctx_t);
        pub fn tk_encryption_generate_key(ctx: *mut tk_encryption_ctx_t) -> tk_error_code_t;
        pub fn tk_encryption_encrypt(
            ctx: *mut tk_encryption_ctx_t,
            plaintext: *const u8,
            plaintext_size: usize,
            ciphertext: *mut u8,
            ciphertext_size: *mut usize,
        ) -> tk_error_code_t;
        pub fn tk_encryption_decrypt(
            ctx: *mut tk_encryption_ctx_t,
            ciphertext: *const u8,
            ciphertext_size: usize,
            plaintext: *mut u8,
            plaintext_size: *mut usize,
        ) -> tk_error_code_t;
    }

    // From tk_auth_manager.h
    pub enum tk_auth_manager_s {}
    pub type tk_auth_manager_t = tk_auth_manager_s;
    pub enum tk_auth_session_s {}
    pub type tk_auth_session_t = tk_auth_session_s;

    extern "C" {
        pub fn tk_auth_manager_init(auth_mgr: *mut *mut tk_auth_manager_t) -> tk_error_code_t;
        pub fn tk_auth_manager_destroy(auth_mgr: *mut *mut tk_auth_manager_t);
        // ... and so on for all other functions.
    }
}


// --- Public Module Declarations ---

/// Cryptographic key management and operations.
pub mod key_management;

/// Secure communication channels.
pub mod secure_channels;


// --- Public Prelude ---

pub mod prelude {
    //! A "prelude" for convenient imports of the security crate's main types.
    pub use super::{
        key_management::{EncryptionKey, KeyManager},
        SecurityError,
    };
}


// --- Core Public Types ---

use thiserror::Error;

/// The primary error type for all operations within the security crate.
///
/// It consolidates errors from various sub-modules and FFI calls into a
/// single, easy-to-handle type.
#[derive(Debug, Error)]
pub enum SecurityError {
    /// An error occurred during an FFI call to the underlying C library.
    /// The string provides context about the failed operation.
    #[error("FFI call failed: {0}")]
    Ffi(String),

    /// A required resource (like a key or context) was not initialized.
    #[error("Resource not initialized: {0}")]
    NotInitialized(String),

    /// An invalid argument was provided to a function.
    #[error("Invalid argument: {0}")]
    InvalidArgument(String),

    /// A buffer provided was too small for the operation.
    #[error("Buffer is too small. Required: {required}, available: {available}")]
    BufferTooSmall {
        /// The required size for the buffer.
        required: usize,
        /// The available size of the buffer.
        available: usize,
    },

    /// Decryption failed, likely due to tampered data or an incorrect key.
    /// This is a critical error, as it indicates a potential security breach.
    #[error("Decryption failed. The data may be corrupt or tampered with.")]
    DecryptionFailed,

    /// An error occurred during key management operations.
    #[error("Key management error: {0}")]
    KeyManagement(#[from] key_management::KeyError),

    /// A generic I/O error.
    #[error("I/O error: {0}")]
    Io(#[from] std::io::Error),
}

/// A helper function to convert C-style error codes into `SecurityError`.
///
/// This is a private utility but central to the crate's safety strategy.
///
/// # Arguments
/// * `code` - The `tk_error_code_t` returned from an FFI call.
/// * `context` - A string describing the operation that was attempted.
///
/// # Returns
/// * `Ok(())` if the code is `TK_SUCCESS`.
/// * `Err(SecurityError)` for any other code.
fn ffi_result_from_code(code: ffi::tk_error_code_t, context: &str) -> Result<(), SecurityError> {
    const TK_ERROR_BUFFER_TOO_SMALL: i32 = -2; // Example value
    const TK_ERROR_DECRYPTION_FAILED: i32 = -10; // Example value

    match code {
        ffi::TK_SUCCESS => Ok(()),
        TK_ERROR_BUFFER_TOO_SMALL => Err(SecurityError::Ffi(format!(
            "Buffer too small during '{}'",
            context
        ))),
        TK_ERROR_DECRYPTION_FAILED => Err(SecurityError::DecryptionFailed),
        _ => Err(SecurityError::Ffi(format!(
            "An unknown error occurred during '{}' (code: {})",
            context, code
        ))),
    }
}
